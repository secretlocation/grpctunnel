// Code generated by protoc-gen-go. DO NOT EDIT.
// source: github.com/secretlocation/grpctunnel/tunnel.proto

package grpctunnel

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	status "google.golang.org/genproto/googleapis/rpc/status"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status1 "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// ClientToServer is the message a client sends to a server.
//
// For a single stream ID, the first such message must include the new_stream
// field. After that, there can be any number of requests sent, via the
// request_message field and additional messages thereafter that use the
// more_request_data field (for requests that are larger than 16kb). And
// finally, the RPC ends with either the half_close or cancel fields. If the
// half_close field is used, the RPC stream remains active so the server may
// continue to send response data. But, if the cancel field is used, the RPC
// stream is aborted and thus closed on both client and server ends. If a stream
// has been half-closed, the only allowed message from the client for that
// stream ID is one with the cancel field, to abort the remainder of the
// operation.
type ClientToServer struct {
	// The ID of the stream. Stream IDs must be used in increasing order and
	// cannot be re-used. Unlike in the HTTP/2 protocol, the stream ID is 64-bit
	// so overflow in a long-lived channel is excessively unlikely. (If the
	// channel were used for a stream every nanosecond, it would take close to
	// 300 years to exhaust every ID and reach an overflow situation.)
	StreamId int64 `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// Types that are valid to be assigned to Frame:
	//	*ClientToServer_NewStream
	//	*ClientToServer_RequestMessage
	//	*ClientToServer_MoreRequestData
	//	*ClientToServer_HalfClose
	//	*ClientToServer_Cancel
	Frame                isClientToServer_Frame `protobuf_oneof:"frame"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ClientToServer) Reset()         { *m = ClientToServer{} }
func (m *ClientToServer) String() string { return proto.CompactTextString(m) }
func (*ClientToServer) ProtoMessage()    {}
func (*ClientToServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{0}
}

func (m *ClientToServer) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientToServer.Unmarshal(m, b)
}
func (m *ClientToServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientToServer.Marshal(b, m, deterministic)
}
func (m *ClientToServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientToServer.Merge(m, src)
}
func (m *ClientToServer) XXX_Size() int {
	return xxx_messageInfo_ClientToServer.Size(m)
}
func (m *ClientToServer) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientToServer.DiscardUnknown(m)
}

var xxx_messageInfo_ClientToServer proto.InternalMessageInfo

func (m *ClientToServer) GetStreamId() int64 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

type isClientToServer_Frame interface {
	isClientToServer_Frame()
}

type ClientToServer_NewStream struct {
	NewStream *NewStream `protobuf:"bytes,2,opt,name=new_stream,json=newStream,proto3,oneof"`
}

type ClientToServer_RequestMessage struct {
	RequestMessage *MessageData `protobuf:"bytes,3,opt,name=request_message,json=requestMessage,proto3,oneof"`
}

type ClientToServer_MoreRequestData struct {
	MoreRequestData []byte `protobuf:"bytes,4,opt,name=more_request_data,json=moreRequestData,proto3,oneof"`
}

type ClientToServer_HalfClose struct {
	HalfClose *empty.Empty `protobuf:"bytes,5,opt,name=half_close,json=halfClose,proto3,oneof"`
}

type ClientToServer_Cancel struct {
	Cancel *empty.Empty `protobuf:"bytes,6,opt,name=cancel,proto3,oneof"`
}

func (*ClientToServer_NewStream) isClientToServer_Frame() {}

func (*ClientToServer_RequestMessage) isClientToServer_Frame() {}

func (*ClientToServer_MoreRequestData) isClientToServer_Frame() {}

func (*ClientToServer_HalfClose) isClientToServer_Frame() {}

func (*ClientToServer_Cancel) isClientToServer_Frame() {}

func (m *ClientToServer) GetFrame() isClientToServer_Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *ClientToServer) GetNewStream() *NewStream {
	if x, ok := m.GetFrame().(*ClientToServer_NewStream); ok {
		return x.NewStream
	}
	return nil
}

func (m *ClientToServer) GetRequestMessage() *MessageData {
	if x, ok := m.GetFrame().(*ClientToServer_RequestMessage); ok {
		return x.RequestMessage
	}
	return nil
}

func (m *ClientToServer) GetMoreRequestData() []byte {
	if x, ok := m.GetFrame().(*ClientToServer_MoreRequestData); ok {
		return x.MoreRequestData
	}
	return nil
}

func (m *ClientToServer) GetHalfClose() *empty.Empty {
	if x, ok := m.GetFrame().(*ClientToServer_HalfClose); ok {
		return x.HalfClose
	}
	return nil
}

func (m *ClientToServer) GetCancel() *empty.Empty {
	if x, ok := m.GetFrame().(*ClientToServer_Cancel); ok {
		return x.Cancel
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ClientToServer) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ClientToServer_NewStream)(nil),
		(*ClientToServer_RequestMessage)(nil),
		(*ClientToServer_MoreRequestData)(nil),
		(*ClientToServer_HalfClose)(nil),
		(*ClientToServer_Cancel)(nil),
	}
}

// ServerToClient is the message a server sends to a client.
//
// For a single stream ID, the first such message should include the
// response_headers field unless no headers are to be sent. After the headers,
// the server can send any number of responses, via the response_message field
// and additional messages thereafter that use the more_response_data field (for
// responses that are larger than 16kb). A message with the close_stream field
// concludes the stream, whether it terminates successfully or with an error.
type ServerToClient struct {
	// The ID of the stream. Stream IDs are defined by the client and should be
	// used in monotonically increasing order. They cannot be re-used. Unlike
	// HTTP/2, the ID is 64-bit, so overflow/re-use should not be an issue. (If
	// the channel were used for a stream every nanosecond, it would take close
	// to 300 years to exhaust every ID and reach an overflow situation.)
	StreamId int64 `protobuf:"varint,1,opt,name=stream_id,json=streamId,proto3" json:"stream_id,omitempty"`
	// Types that are valid to be assigned to Frame:
	//	*ServerToClient_ResponseHeaders
	//	*ServerToClient_ResponseMessage
	//	*ServerToClient_MoreResponseData
	//	*ServerToClient_CloseStream
	//	*ServerToClient_ServerInfo
	Frame                isServerToClient_Frame `protobuf_oneof:"frame"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ServerToClient) Reset()         { *m = ServerToClient{} }
func (m *ServerToClient) String() string { return proto.CompactTextString(m) }
func (*ServerToClient) ProtoMessage()    {}
func (*ServerToClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{1}
}

func (m *ServerToClient) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerToClient.Unmarshal(m, b)
}
func (m *ServerToClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerToClient.Marshal(b, m, deterministic)
}
func (m *ServerToClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerToClient.Merge(m, src)
}
func (m *ServerToClient) XXX_Size() int {
	return xxx_messageInfo_ServerToClient.Size(m)
}
func (m *ServerToClient) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerToClient.DiscardUnknown(m)
}

var xxx_messageInfo_ServerToClient proto.InternalMessageInfo

func (m *ServerToClient) GetStreamId() int64 {
	if m != nil {
		return m.StreamId
	}
	return 0
}

type isServerToClient_Frame interface {
	isServerToClient_Frame()
}

type ServerToClient_ResponseHeaders struct {
	ResponseHeaders *Metadata `protobuf:"bytes,2,opt,name=response_headers,json=responseHeaders,proto3,oneof"`
}

type ServerToClient_ResponseMessage struct {
	ResponseMessage *MessageData `protobuf:"bytes,3,opt,name=response_message,json=responseMessage,proto3,oneof"`
}

type ServerToClient_MoreResponseData struct {
	MoreResponseData []byte `protobuf:"bytes,4,opt,name=more_response_data,json=moreResponseData,proto3,oneof"`
}

type ServerToClient_CloseStream struct {
	CloseStream *CloseStream `protobuf:"bytes,5,opt,name=close_stream,json=closeStream,proto3,oneof"`
}

type ServerToClient_ServerInfo struct {
	ServerInfo *MessageData `protobuf:"bytes,6,opt,name=server_info,json=serverInfo,proto3,oneof"`
}

func (*ServerToClient_ResponseHeaders) isServerToClient_Frame() {}

func (*ServerToClient_ResponseMessage) isServerToClient_Frame() {}

func (*ServerToClient_MoreResponseData) isServerToClient_Frame() {}

func (*ServerToClient_CloseStream) isServerToClient_Frame() {}

func (*ServerToClient_ServerInfo) isServerToClient_Frame() {}

func (m *ServerToClient) GetFrame() isServerToClient_Frame {
	if m != nil {
		return m.Frame
	}
	return nil
}

func (m *ServerToClient) GetResponseHeaders() *Metadata {
	if x, ok := m.GetFrame().(*ServerToClient_ResponseHeaders); ok {
		return x.ResponseHeaders
	}
	return nil
}

func (m *ServerToClient) GetResponseMessage() *MessageData {
	if x, ok := m.GetFrame().(*ServerToClient_ResponseMessage); ok {
		return x.ResponseMessage
	}
	return nil
}

func (m *ServerToClient) GetMoreResponseData() []byte {
	if x, ok := m.GetFrame().(*ServerToClient_MoreResponseData); ok {
		return x.MoreResponseData
	}
	return nil
}

func (m *ServerToClient) GetCloseStream() *CloseStream {
	if x, ok := m.GetFrame().(*ServerToClient_CloseStream); ok {
		return x.CloseStream
	}
	return nil
}

func (m *ServerToClient) GetServerInfo() *MessageData {
	if x, ok := m.GetFrame().(*ServerToClient_ServerInfo); ok {
		return x.ServerInfo
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ServerToClient) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ServerToClient_ResponseHeaders)(nil),
		(*ServerToClient_ResponseMessage)(nil),
		(*ServerToClient_MoreResponseData)(nil),
		(*ServerToClient_CloseStream)(nil),
		(*ServerToClient_ServerInfo)(nil),
	}
}

type NewStream struct {
	MethodName           string    `protobuf:"bytes,1,opt,name=method_name,json=methodName,proto3" json:"method_name,omitempty"`
	RequestHeaders       *Metadata `protobuf:"bytes,2,opt,name=request_headers,json=requestHeaders,proto3" json:"request_headers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *NewStream) Reset()         { *m = NewStream{} }
func (m *NewStream) String() string { return proto.CompactTextString(m) }
func (*NewStream) ProtoMessage()    {}
func (*NewStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{2}
}

func (m *NewStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NewStream.Unmarshal(m, b)
}
func (m *NewStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NewStream.Marshal(b, m, deterministic)
}
func (m *NewStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewStream.Merge(m, src)
}
func (m *NewStream) XXX_Size() int {
	return xxx_messageInfo_NewStream.Size(m)
}
func (m *NewStream) XXX_DiscardUnknown() {
	xxx_messageInfo_NewStream.DiscardUnknown(m)
}

var xxx_messageInfo_NewStream proto.InternalMessageInfo

func (m *NewStream) GetMethodName() string {
	if m != nil {
		return m.MethodName
	}
	return ""
}

func (m *NewStream) GetRequestHeaders() *Metadata {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

type MessageData struct {
	// The full size of the message.
	Size int32 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// The message data. This field should not be longer than 16kb (16,384
	// bytes). If the full size of the message is larger then it should be
	// split into multiple chunks. The chunking is done to allow multiple
	// access to the underlying gRPC stream by concurrent tunneled streams.
	// If very large messages were sent via a single chunk, it could cause
	// head-of-line blocking and starvation when multiple streams need to send
	// data on the one underlying gRPC stream.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MessageData) Reset()         { *m = MessageData{} }
func (m *MessageData) String() string { return proto.CompactTextString(m) }
func (*MessageData) ProtoMessage()    {}
func (*MessageData) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{3}
}

func (m *MessageData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MessageData.Unmarshal(m, b)
}
func (m *MessageData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MessageData.Marshal(b, m, deterministic)
}
func (m *MessageData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageData.Merge(m, src)
}
func (m *MessageData) XXX_Size() int {
	return xxx_messageInfo_MessageData.Size(m)
}
func (m *MessageData) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageData.DiscardUnknown(m)
}

var xxx_messageInfo_MessageData proto.InternalMessageInfo

func (m *MessageData) GetSize() int32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *MessageData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CloseStream struct {
	ResponseTrailers     *Metadata      `protobuf:"bytes,1,opt,name=response_trailers,json=responseTrailers,proto3" json:"response_trailers,omitempty"`
	Status               *status.Status `protobuf:"bytes,2,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CloseStream) Reset()         { *m = CloseStream{} }
func (m *CloseStream) String() string { return proto.CompactTextString(m) }
func (*CloseStream) ProtoMessage()    {}
func (*CloseStream) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{4}
}

func (m *CloseStream) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CloseStream.Unmarshal(m, b)
}
func (m *CloseStream) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CloseStream.Marshal(b, m, deterministic)
}
func (m *CloseStream) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseStream.Merge(m, src)
}
func (m *CloseStream) XXX_Size() int {
	return xxx_messageInfo_CloseStream.Size(m)
}
func (m *CloseStream) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseStream.DiscardUnknown(m)
}

var xxx_messageInfo_CloseStream proto.InternalMessageInfo

func (m *CloseStream) GetResponseTrailers() *Metadata {
	if m != nil {
		return m.ResponseTrailers
	}
	return nil
}

func (m *CloseStream) GetStatus() *status.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

type Metadata struct {
	Md                   map[string]*Metadata_Values `protobuf:"bytes,1,rep,name=md,proto3" json:"md,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{5}
}

func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata.Unmarshal(m, b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return xxx_messageInfo_Metadata.Size(m)
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetMd() map[string]*Metadata_Values {
	if m != nil {
		return m.Md
	}
	return nil
}

type Metadata_Values struct {
	Val                  []string `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metadata_Values) Reset()         { *m = Metadata_Values{} }
func (m *Metadata_Values) String() string { return proto.CompactTextString(m) }
func (*Metadata_Values) ProtoMessage()    {}
func (*Metadata_Values) Descriptor() ([]byte, []int) {
	return fileDescriptor_bd30a96cf4221d82, []int{5, 0}
}

func (m *Metadata_Values) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Metadata_Values.Unmarshal(m, b)
}
func (m *Metadata_Values) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Metadata_Values.Marshal(b, m, deterministic)
}
func (m *Metadata_Values) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata_Values.Merge(m, src)
}
func (m *Metadata_Values) XXX_Size() int {
	return xxx_messageInfo_Metadata_Values.Size(m)
}
func (m *Metadata_Values) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata_Values.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata_Values proto.InternalMessageInfo

func (m *Metadata_Values) GetVal() []string {
	if m != nil {
		return m.Val
	}
	return nil
}

func init() {
	proto.RegisterType((*ClientToServer)(nil), "grpctunnel.ClientToServer")
	proto.RegisterType((*ServerToClient)(nil), "grpctunnel.ServerToClient")
	proto.RegisterType((*NewStream)(nil), "grpctunnel.NewStream")
	proto.RegisterType((*MessageData)(nil), "grpctunnel.MessageData")
	proto.RegisterType((*CloseStream)(nil), "grpctunnel.CloseStream")
	proto.RegisterType((*Metadata)(nil), "grpctunnel.Metadata")
	proto.RegisterMapType((map[string]*Metadata_Values)(nil), "grpctunnel.Metadata.MdEntry")
	proto.RegisterType((*Metadata_Values)(nil), "grpctunnel.Metadata.Values")
}

func init() {
	proto.RegisterFile("github.com/secretlocation/grpctunnel/tunnel.proto", fileDescriptor_bd30a96cf4221d82)
}

var fileDescriptor_bd30a96cf4221d82 = []byte{
	// 663 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xdb, 0x4e, 0xdb, 0x4a,
	0x14, 0x86, 0x71, 0x42, 0x02, 0x59, 0x61, 0x73, 0x18, 0xed, 0xbd, 0x89, 0xcc, 0x96, 0x36, 0xca,
	0x55, 0x54, 0x21, 0x07, 0xa8, 0x7a, 0x10, 0x6a, 0x2f, 0x38, 0x49, 0xe1, 0x02, 0x90, 0x86, 0xa8,
	0xb7, 0xd6, 0x60, 0xaf, 0x24, 0x16, 0xb6, 0xc7, 0x9d, 0x99, 0x04, 0x51, 0xf5, 0x81, 0xaa, 0xbe,
	0x4a, 0x9f, 0xa4, 0x6f, 0x51, 0xcd, 0xc1, 0x39, 0xa8, 0x28, 0xe5, 0x2a, 0x33, 0xeb, 0xff, 0xd7,
	0x41, 0x5f, 0xd6, 0x18, 0x8e, 0x86, 0x89, 0x1a, 0x8d, 0xef, 0x83, 0x88, 0x67, 0x5d, 0x89, 0x91,
	0x40, 0x95, 0xf2, 0x88, 0xa9, 0x84, 0xe7, 0xdd, 0xa1, 0x28, 0x22, 0x35, 0xce, 0x73, 0x4c, 0xbb,
	0xf6, 0x27, 0x28, 0x04, 0x57, 0x9c, 0xc0, 0x4c, 0xf0, 0xf7, 0x86, 0x9c, 0x0f, 0x53, 0xec, 0x1a,
	0xe5, 0x7e, 0x3c, 0xe8, 0x62, 0x56, 0xa8, 0x27, 0x6b, 0xf4, 0x77, 0x9d, 0x28, 0x8a, 0xa8, 0x2b,
	0x15, 0x53, 0x63, 0x69, 0x85, 0xf6, 0x8f, 0x0a, 0x6c, 0x9e, 0xa7, 0x09, 0xe6, 0xaa, 0xcf, 0xef,
	0x50, 0x4c, 0x50, 0x90, 0x3d, 0x68, 0x48, 0x25, 0x90, 0x65, 0x61, 0x12, 0xb7, 0xbc, 0x7d, 0xaf,
	0x53, 0xa5, 0xeb, 0x36, 0x70, 0x15, 0x93, 0xb7, 0x00, 0x39, 0x3e, 0x86, 0xf6, 0xde, 0xaa, 0xec,
	0x7b, 0x9d, 0xe6, 0xf1, 0x3f, 0xc1, 0x6c, 0x8c, 0xe0, 0x06, 0x1f, 0xef, 0x8c, 0xd8, 0x5b, 0xa1,
	0x8d, 0xbc, 0xbc, 0x90, 0x33, 0xd8, 0x12, 0xf8, 0x79, 0x8c, 0x52, 0x85, 0x19, 0x4a, 0xc9, 0x86,
	0xd8, 0xaa, 0x9a, 0xe4, 0xdd, 0xf9, 0xe4, 0x6b, 0x2b, 0x5d, 0x30, 0xc5, 0x7a, 0x2b, 0x74, 0xd3,
	0x65, 0xb8, 0x28, 0x39, 0x80, 0x9d, 0x8c, 0x0b, 0x0c, 0xcb, 0x42, 0x31, 0x53, 0xac, 0xb5, 0xba,
	0xef, 0x75, 0x36, 0x7a, 0x2b, 0x74, 0x4b, 0x4b, 0xd4, 0x2a, 0x3a, 0x9f, 0xbc, 0x03, 0x18, 0xb1,
	0x74, 0x10, 0x46, 0x29, 0x97, 0xd8, 0xaa, 0x99, 0x66, 0xff, 0x06, 0x96, 0x43, 0x50, 0x42, 0x0a,
	0x2e, 0x35, 0x24, 0x3d, 0xaa, 0xf6, 0x9e, 0x6b, 0x2b, 0x39, 0x84, 0x7a, 0xc4, 0xf2, 0x08, 0xd3,
	0x56, 0xfd, 0x0f, 0x49, 0xce, 0x77, 0xb6, 0x06, 0xb5, 0x81, 0x60, 0x19, 0xb6, 0x7f, 0x56, 0x60,
	0xd3, 0x52, 0xec, 0x73, 0x4b, 0x75, 0x39, 0xcd, 0x53, 0xd8, 0x16, 0x28, 0x0b, 0x9e, 0x4b, 0x0c,
	0x47, 0xc8, 0x62, 0x14, 0xd2, 0x31, 0xfd, 0x7b, 0x11, 0x8b, 0x62, 0xb1, 0x65, 0xb2, 0x55, 0xfa,
	0x7b, 0xd6, 0x4e, 0x2e, 0xe6, 0x4a, 0xbc, 0x98, 0xec, 0xb4, 0x4a, 0x89, 0x36, 0x00, 0xe2, 0xd0,
	0xba, 0x52, 0x0b, 0x6c, 0xb7, 0x2d, 0x5b, 0x2b, 0x19, 0xb8, 0x1f, 0x60, 0xc3, 0x70, 0x2d, 0x17,
	0xa1, 0xf6, 0x7b, 0x47, 0x03, 0x73, 0xba, 0x0a, 0xcd, 0x68, 0x76, 0x25, 0x27, 0xd0, 0x94, 0x86,
	0x52, 0x98, 0xe4, 0x03, 0xee, 0x30, 0x2f, 0x19, 0x17, 0xac, 0xfb, 0x2a, 0x1f, 0xf0, 0x19, 0xeb,
	0x07, 0x68, 0x4c, 0x77, 0x8d, 0xfc, 0x0f, 0xcd, 0x0c, 0xd5, 0x88, 0xc7, 0x61, 0xce, 0x32, 0x34,
	0x9c, 0x1b, 0x14, 0x6c, 0xe8, 0x86, 0x65, 0x48, 0x3e, 0xce, 0xf6, 0xef, 0x05, 0xa0, 0xa7, 0xab,
	0xe7, 0x28, 0xb7, 0xdf, 0x40, 0x73, 0x6e, 0x24, 0x42, 0x60, 0x55, 0x26, 0x5f, 0x6c, 0x9f, 0x1a,
	0x35, 0x67, 0x1d, 0x33, 0xd0, 0x74, 0xd9, 0x0d, 0x6a, 0xce, 0xed, 0xaf, 0xd0, 0x9c, 0xc3, 0x40,
	0x4e, 0x61, 0x67, 0x0a, 0x58, 0x09, 0x96, 0xa4, 0x7a, 0x0c, 0x6f, 0xc9, 0x18, 0xd3, 0xbf, 0xb6,
	0xef, 0xdc, 0xe4, 0x15, 0xd4, 0xed, 0xfb, 0x75, 0xe3, 0x93, 0x72, 0x39, 0x45, 0x11, 0x05, 0x77,
	0x46, 0xa1, 0xce, 0xd1, 0xfe, 0xe6, 0xc1, 0x7a, 0x59, 0x8a, 0x1c, 0x40, 0x25, 0xd3, 0x0b, 0x58,
	0xed, 0x34, 0x8f, 0xff, 0x7b, 0xae, 0x59, 0x70, 0x1d, 0x5f, 0xe6, 0x4a, 0x3c, 0xd1, 0x4a, 0x16,
	0xfb, 0x3e, 0xd4, 0x3f, 0xb1, 0x74, 0x8c, 0x92, 0x6c, 0x43, 0x75, 0xc2, 0x52, 0x93, 0xd8, 0xa0,
	0xfa, 0xe8, 0x53, 0x58, 0x73, 0x56, 0x2d, 0x3e, 0xe0, 0x93, 0xc3, 0xad, 0x8f, 0xe4, 0x08, 0x6a,
	0x13, 0x9d, 0xe8, 0xc6, 0xdb, 0x7b, 0xb6, 0x93, 0x2d, 0x4d, 0xad, 0xf3, 0xa4, 0xf2, 0xde, 0x3b,
	0xfe, 0xee, 0xc1, 0x5f, 0x7d, 0xe3, 0xd2, 0xcf, 0x27, 0x89, 0x90, 0xf4, 0x00, 0x6e, 0x0b, 0xcc,
	0x6d, 0x90, 0xf8, 0x8b, 0x9b, 0x35, 0xff, 0xbd, 0xf2, 0x17, 0xb4, 0xc5, 0xd7, 0xd7, 0xf1, 0x0e,
	0x3d, 0x72, 0x0b, 0x3b, 0xba, 0x12, 0xc5, 0x09, 0x0a, 0x89, 0xcf, 0x15, 0x5c, 0x4c, 0xf2, 0x97,
	0x34, 0xd3, 0x05, 0xef, 0xeb, 0xe6, 0x43, 0xf0, 0xfa, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0x1e,
	0x47, 0x57, 0x9b, 0xb1, 0x05, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// TunnelServiceClient is the client API for TunnelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TunnelServiceClient interface {
	// OpenTunnel creates a channel to the server which can be used to send
	// additional RPCs, all of which will be sent to the same server via a
	// single underlying gRPC stream. This can provide affinity for a "chatty"
	// sequence of calls, where the gRPC connection is load balanced (so there
	// may be multiple backend servers), but a particular "conversation" (which
	// may consist of numerous RPCs) needs to all go to a single server, for
	// consistency.
	OpenTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenTunnelClient, error)
	// OpenReverseTunnel creates a "reverse" channel, which allows the server to
	// act as a client and send RPCs to the client that creates the tunnel. It
	// is in most respects identical to OpenTunnel except that the roles are
	// reversed: the server initiates RPCs and sends requests and the client
	// replies to them and sends responses.
	OpenReverseTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenReverseTunnelClient, error)
}

type tunnelServiceClient struct {
	cc *grpc.ClientConn
}

func NewTunnelServiceClient(cc *grpc.ClientConn) TunnelServiceClient {
	return &tunnelServiceClient{cc}
}

func (c *tunnelServiceClient) OpenTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TunnelService_serviceDesc.Streams[0], "/grpctunnel.TunnelService/OpenTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &tunnelServiceOpenTunnelClient{stream}
	return x, nil
}

type TunnelService_OpenTunnelClient interface {
	Send(*ClientToServer) error
	Recv() (*ServerToClient, error)
	grpc.ClientStream
}

type tunnelServiceOpenTunnelClient struct {
	grpc.ClientStream
}

func (x *tunnelServiceOpenTunnelClient) Send(m *ClientToServer) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tunnelServiceOpenTunnelClient) Recv() (*ServerToClient, error) {
	m := new(ServerToClient)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tunnelServiceClient) OpenReverseTunnel(ctx context.Context, opts ...grpc.CallOption) (TunnelService_OpenReverseTunnelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_TunnelService_serviceDesc.Streams[1], "/grpctunnel.TunnelService/OpenReverseTunnel", opts...)
	if err != nil {
		return nil, err
	}
	x := &tunnelServiceOpenReverseTunnelClient{stream}
	return x, nil
}

type TunnelService_OpenReverseTunnelClient interface {
	Send(*ServerToClient) error
	Recv() (*ClientToServer, error)
	grpc.ClientStream
}

type tunnelServiceOpenReverseTunnelClient struct {
	grpc.ClientStream
}

func (x *tunnelServiceOpenReverseTunnelClient) Send(m *ServerToClient) error {
	return x.ClientStream.SendMsg(m)
}

func (x *tunnelServiceOpenReverseTunnelClient) Recv() (*ClientToServer, error) {
	m := new(ClientToServer)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// TunnelServiceServer is the server API for TunnelService service.
type TunnelServiceServer interface {
	// OpenTunnel creates a channel to the server which can be used to send
	// additional RPCs, all of which will be sent to the same server via a
	// single underlying gRPC stream. This can provide affinity for a "chatty"
	// sequence of calls, where the gRPC connection is load balanced (so there
	// may be multiple backend servers), but a particular "conversation" (which
	// may consist of numerous RPCs) needs to all go to a single server, for
	// consistency.
	OpenTunnel(TunnelService_OpenTunnelServer) error
	// OpenReverseTunnel creates a "reverse" channel, which allows the server to
	// act as a client and send RPCs to the client that creates the tunnel. It
	// is in most respects identical to OpenTunnel except that the roles are
	// reversed: the server initiates RPCs and sends requests and the client
	// replies to them and sends responses.
	OpenReverseTunnel(TunnelService_OpenReverseTunnelServer) error
}

// UnimplementedTunnelServiceServer can be embedded to have forward compatible implementations.
type UnimplementedTunnelServiceServer struct {
}

func (*UnimplementedTunnelServiceServer) OpenTunnel(srv TunnelService_OpenTunnelServer) error {
	return status1.Errorf(codes.Unimplemented, "method OpenTunnel not implemented")
}
func (*UnimplementedTunnelServiceServer) OpenReverseTunnel(srv TunnelService_OpenReverseTunnelServer) error {
	return status1.Errorf(codes.Unimplemented, "method OpenReverseTunnel not implemented")
}

func RegisterTunnelServiceServer(s *grpc.Server, srv TunnelServiceServer) {
	s.RegisterService(&_TunnelService_serviceDesc, srv)
}

func _TunnelService_OpenTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TunnelServiceServer).OpenTunnel(&tunnelServiceOpenTunnelServer{stream})
}

type TunnelService_OpenTunnelServer interface {
	Send(*ServerToClient) error
	Recv() (*ClientToServer, error)
	grpc.ServerStream
}

type tunnelServiceOpenTunnelServer struct {
	grpc.ServerStream
}

func (x *tunnelServiceOpenTunnelServer) Send(m *ServerToClient) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tunnelServiceOpenTunnelServer) Recv() (*ClientToServer, error) {
	m := new(ClientToServer)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _TunnelService_OpenReverseTunnel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(TunnelServiceServer).OpenReverseTunnel(&tunnelServiceOpenReverseTunnelServer{stream})
}

type TunnelService_OpenReverseTunnelServer interface {
	Send(*ClientToServer) error
	Recv() (*ServerToClient, error)
	grpc.ServerStream
}

type tunnelServiceOpenReverseTunnelServer struct {
	grpc.ServerStream
}

func (x *tunnelServiceOpenReverseTunnelServer) Send(m *ClientToServer) error {
	return x.ServerStream.SendMsg(m)
}

func (x *tunnelServiceOpenReverseTunnelServer) Recv() (*ServerToClient, error) {
	m := new(ServerToClient)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _TunnelService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpctunnel.TunnelService",
	HandlerType: (*TunnelServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenTunnel",
			Handler:       _TunnelService_OpenTunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "OpenReverseTunnel",
			Handler:       _TunnelService_OpenReverseTunnel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "github.com/secretlocation/grpctunnel/tunnel.proto",
}
